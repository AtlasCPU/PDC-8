# PDC-8
The ATLAS PDC-8 is a homebrew computer of my own design, which is being built as my high school senior project. 

Watch a demo of it calculating fibonacci numbers [here](https://www.youtube.com/watch?v=G-2V7RjiHaM)

# Constraints
The initialism "PDC" stands for "Personal Data Controller, which harkens back to old-school computer names like "Programmable Data Processor" (PDP) and "Universal Automatic Computer (UNIVAC). Indeed, the PDC-8 is meant to somewhat represent a low-cost, consumer-oriented minicomputer from the early 1970s. For the sake of my own time and sanity, it has been designed to be simple and easy to assemble. At the same time, I've designed it to be capable of running complex programs (not a 4-bit "toy" machine with 16 bytes of memory), and to have a high degree of expandability.

# Architecture

![pcu drawio](https://user-images.githubusercontent.com/83188735/156493896-94b9633b-cfd6-4771-a585-894bc2892066.png)

The PDC-8 is a Harvard architecture machine, with program memory separate from data memory, and no provisions for randomly reading from/writing to program memory. This has been done for the sake of simplicity, as it greatly reduces the amount of neccessary decoding and control logic.

It features several registers, which can be manipulated by the programmer.<br>
ACC - Accumulator, general purpose register<br>
MAR - Memory address register, points to location in data memory<br>
OP - Operation, sets ALU operation mode<br>
SUM - Sum, stores ALU result<br>
PC - Program counter, points to location in program memory<br>
DISP - Display, holds value to be shown on 7-segment display<br>
CE - Flags, holds CARRY and EQUALS flag generated by ALU<br>

Both the program counter and memory address register are 8-bits wide, allowing the PCU-8 to access up to 256 bytes of program memory, and 256 bytes of data memory. However, this could easily be expanded.

# Instruction set

The PDC-8 follows a simple transport triggered architectural model. By extension, this means that it could be considered an OISC (one instruction set computer), as the only instruction available moves data from one register to another, and checks one of three selected conditions. Although only having a single instruction may seem limited, it has proven to be surprisingly efficient and versatile. Since each instruction only takes a single clock cycle to execute, many operations take less cycles on the PDC-8 than they would on a more complex machine. At the same time, being able to move data between any two registers allows for the progammer to implement subroutine jumps, stack operations, and a whole host of other advanced features.

Each instruction is made up of an 8-bit immediate value, and an 8-bit control word, which is outlined below. This makes for a 16-bit wide program memory.

CC SSS DDD XXXXXXXX

Condition select<br>
00 - None<br>
01 - Allow jump if CARRY = 1<br>
10 - Allow jump if EQUALS = 1<br>
11 - Allow jump if EQUALS != 1<br>

Store select<br>
000 - None<br>
001 - ACC store<br>
010 - MEM store<br>
011 - SUM store<br>
100 - OP store<br>
101 - PC store (jump)<br>
111 - DISP store<br>

Data out select<br>
000 - None<br>
001 - ACC data out<br>
010 - MEM data out<br>
011 - SUM data out<br>
100 - IMM data out<br>

X = 8-bit immediate value

As there is no room for ALU opcodes in the control word, ALU operation modes must be selected by writing an immediate value to the OP register. There is also no space for in-line memory addresses, so you must first write an immediate value to the MAR register before accessing your desired memory location. Once more, this has been done for the sake of simplicity. However, it also means that you can make use of any conceviable addressing mode through software.

# Construction

![IMG_20220223_232938325](https://user-images.githubusercontent.com/83188735/156496784-83260c00-0056-436a-999d-c3e7b49d8fd2.jpg)

The PDC-8 will be spread across four perfboard cards, which will plug into four of six 2x40 pin sockets on a backplane. It will be controlled and programmed through the front panel, though you'll also be able to use an Arduino to transfer programs from another computer. I will be using wire wrap as the main way of connecting chips, as it is cheap and easily modifiable.

# Software

![simulator](https://user-images.githubusercontent.com/83188735/156498358-6f9f5ca1-a745-4a2c-b251-45fccfedc3bc.jpg)

I've made a simulator in the amazing application [hneemann Digital](https://github.com/hneemann/Digital). Right now, it's loaded with a simple fibonacci program I wrote. 
